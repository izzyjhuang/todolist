// App.js

import React, { useEffect } from 'react';
import { PrioritiesProvider } from './components/PrioritiesContext';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { NavigationContainer } from '@react-navigation/native';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import { Ionicons, MaterialIcons } from '@expo/vector-icons';
import Icon from 'react-native-vector-icons/MaterialIcons';


import TodayScreen from './screens/TodayScreen';
import TomorrowScreen from './screens/TomorrowScreen';
import SearchScreen from './screens/SearchScreen';
// import BrowseScreen from './screens/BrowseScreen';
import DateIcon from './components/DateIcon';
import RoutineScreen from './screens/RoutineScreen';



const Tab = createBottomTabNavigator();

export default function App() {
  const today = new Date();
  const tomorrow = new Date(today);
  tomorrow.setDate(today.getDate() + 1);

  const getWeekday = (date) => {
    return new Intl.DateTimeFormat('en-US', { weekday: 'short' }).format(date);
  };

  const getDayOfMonth = (date) => {
    return date.getDate();
  };

  const todayWeekday = getWeekday(today);
  const tomorrowWeekday = getWeekday(tomorrow);
  const todayDate = getDayOfMonth(today);
  const tomorrowDate = getDayOfMonth(tomorrow);

  // Schedule task move from TomorrowScreen to TodayScreen at 3 AM
  useEffect(() => {
    const moveTasksToToday = async () => {
      const tomorrowTasks = await AsyncStorage.getItem('tomorrowTasks');
      if (tomorrowTasks) {
        await AsyncStorage.setItem('todayTasks', tomorrowTasks); // Move tasks
        await AsyncStorage.removeItem('tomorrowTasks'); // Clear tomorrow's tasks
      }
    };

    const checkTime = () => {
      const now = new Date();
      if (now.getHours() === 0 && now.getMinutes() === 0) {
        moveTasksToToday();
      }
    };

    // Check every minute if it's 3 AM
    const interval = setInterval(checkTime, 60000); // Check every 60 seconds

    return () => clearInterval(interval); // Cleanup the interval on unmount
  }, []);

  useEffect(() => {
    const loadRoutineForTomorrow = async () => {
      const weekday = new Date().toLocaleDateString('en-US', { weekday: 'long' });
      const routine = await AsyncStorage.getItem(`routine${weekday}`);
      if (routine) {
        await AsyncStorage.setItem('tomorrowTasks', routine);
      }
    };

    const checkTime = () => {
      const now = new Date();
      if (now.getHours() === 0 && now.getMinutes() === 2) {
        loadRoutineForTomorrow();
      }
    };

    const interval = setInterval(checkTime, 60000); // Check every 60 seconds
    return () => clearInterval(interval);
  }, []);

  return (
    <PrioritiesProvider>
    <NavigationContainer>
      <Tab.Navigator
        screenOptions={({ route }) => ({
          tabBarIcon: ({ color, size }) => {
            if (route.name === 'Today') {
              return <DateIcon weekday={todayWeekday} date={todayDate} />;
            } else if (route.name === 'Tomorrow') {
              return <DateIcon weekday={tomorrowWeekday} date={tomorrowDate} />;
            } else {
              let iconName;
              if (route.name === 'Search') {
                iconName = 'search';
              } else if (route.name === 'Routine') {
                iconName = 'schedule';
              }
              return <MaterialIcons name={iconName} size={size} color={color} />;
            }
          },
          tabBarActiveTintColor: 'red',
          tabBarInactiveTintColor: 'gray',
        })}
      >
        <Tab.Screen name="Today" component={TodayScreen} />
        <Tab.Screen name="Tomorrow" component={TomorrowScreen} />
        <Tab.Screen name="Search" component={SearchScreen} />
        <Tab.Screen name="Routine" component={RoutineScreen} />
      </Tab.Navigator>
    </NavigationContainer>
    </PrioritiesProvider>
  );
}


import React, { useState, useEffect } from 'react';
import { View, Text, StyleSheet, FlatList, TouchableOpacity, Button } from 'react-native';
import { usePriorities } from '../components/PrioritiesContext';

import AsyncStorage from '@react-native-async-storage/async-storage';
import Icon from 'react-native-vector-icons/MaterialIcons';
import AddTodoModal from '../components/AddTodoModal';
import SettingsModal from '../components/SettingsModal';

const getCurrentTime = () => {
  const now = new Date();
  const hours = now.getHours();
  const minutes = now.getMinutes();
  return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
};

// Function to check if current time is within a block's time range
const isCurrentTimeInRange = (blockTime, currentTime) => {
  const [start, end] = blockTime.split('-');
  return currentTime >= start && currentTime <= end;
};

// Function to calculate the fraction of time passed within a block
const calculateTimeFraction = (blockTime, currentTime) => {
  const [start, end] = blockTime.split('-');
  const [startHour, startMinute] = start.split(':').map(Number);
  const [endHour, endMinute] = end.split(':').map(Number);
  const [currentHour, currentMinute] = currentTime.split(':').map(Number);

  const startTotalMinutes = startHour * 60 + startMinute;
  const endTotalMinutes = endHour * 60 + endMinute;
  const currentTotalMinutes = currentHour * 60 + currentMinute;

  const totalBlockMinutes = endTotalMinutes - startTotalMinutes;
  const passedMinutes = currentTotalMinutes - startTotalMinutes;

  if (passedMinutes < 0 || passedMinutes > totalBlockMinutes) {
    return null;  // Out of block range
  }

  return passedMinutes / totalBlockMinutes;  // Fraction of time passed
};

// Function to get tomorrow's date in the format "Wed, Oct 23"
const getFormattedDate = () => {
    const today = new Date();
    return new Intl.DateTimeFormat('en-US', {
      weekday: 'long',
      month: 'short',
      day: 'numeric',
    }).format(today); // Outputs in the format: Wed, Oct 23
  };
const generateTimeBlocks = (interval = 15, dayStart = '6:00', dayEnd = '23:00') => {
  const blocks = [];
  let [startHour, startMinute] = dayStart.split(':').map(Number);
  let [endHour, endMinute] = dayEnd.split(':').map(Number);

  if (endHour === 0) endHour = 24;

  const startTotalMinutes = startHour * 60 + startMinute;
  const endTotalMinutes = endHour * 60 + endMinute;
  const totalMinutes = endTotalMinutes - startTotalMinutes;
  const totalBlocks = Math.floor(totalMinutes / interval);
  let currentMinutes = startTotalMinutes;

  for (let i = 0; i < totalBlocks; i++) {
    const startHour = Math.floor(currentMinutes / 60);
    const startMinute = currentMinutes % 60;
    const startTime = `${startHour.toString().padStart(2, '0')}:${startMinute
      .toString()
      .padStart(2, '0')}`;

    currentMinutes += interval;

    let endHour = Math.floor(currentMinutes / 60);
    if (endHour === 24) endHour = 0;
    const endMinute = currentMinutes % 60;
    const endTime = `${endHour.toString().padStart(2, '0')}:${endMinute
      .toString()
      .padStart(2, '0')}`;

    const timeRange = `${startTime}-${endTime}`;

    blocks.push({ id: i.toString(), time: timeRange, title: '', description: '', priority: 'none' });
  }

  return blocks;
};

const TodayScreen = () => {
  const { customPriorities, setCustomPriorities } = usePriorities();
  const [dayStart, setDayStart] = useState('6:00');
  const [dayEnd, setDayEnd] = useState('23:00');
  const [blocks, setBlocks] = useState(generateTimeBlocks());
  const [selectedBlocks, setSelectedBlocks] = useState([]);
  const [modalVisible, setModalVisible] = useState(false);
  const [settingsVisible, setSettingsVisible] = useState(false);
  const [isSelecting, setIsSelecting] = useState(false);
  const [entryBlock, setEntryBlock] = useState(null);
  const [history, setHistory] = useState([]);
  const [future, setFuture] = useState([]);
  const [currentBlockId, setCurrentBlockId] = useState(null);
  const [currentTimeFraction, setCurrentTimeFraction] = useState(null);  // Track time fraction


  const [timeInterval, setTimeInterval] = useState(15);
  // const [customPriorities, setCustomPriorities] = useState({
  //   p1: { label: 'p1', color: '#D6B4FC' },
  //   p2: { label: 'p2', color: '#FF8184' },
  //   p3: { label: 'p3', color: '#FDAA48' },
  //   p4: { label: 'p4', color: '#FFFFC5' }
  // });

  

  // Function to locate the current block based on the time
  const locateCurrentBlock = () => {
    const currentTime = getCurrentTime();
    const currentBlock = blocks.find(block => isCurrentTimeInRange(block.time, currentTime));
    if (currentBlock) {
      setCurrentBlockId(currentBlock.id);
      const timeFraction = calculateTimeFraction(currentBlock.time, currentTime);
      setCurrentTimeFraction(timeFraction);  // Set the time fraction for red line position
    } else {
      setCurrentBlockId(null);
      setCurrentTimeFraction(null);  // Clear highlight if no block is found
    }
  };

  // Recalculate the current block every minute
  useEffect(() => {
    locateCurrentBlock();  // Run it when the screen first loads
    const intervalId = setInterval(() => {
      locateCurrentBlock();  // Update every minute
    }, 60000);  // 60000ms = 1 minute
    return () => clearInterval(intervalId);  // Cleanup interval on unmount
  }, [blocks]);  // Re-run when blocks are updated (split/merge)

  useEffect(() => {
    const loadTodayTasks = async () => {
      const storedBlocks = await AsyncStorage.getItem('todayTasks');
      if (storedBlocks) {
        setBlocks(JSON.parse(storedBlocks));
      }
    };
    loadTodayTasks();
  }, []);

  useEffect(() => {
    // Save blocks to AsyncStorage when updated
    const saveTodayTasks = async () => {
      await AsyncStorage.setItem('todayTasks', JSON.stringify(blocks));
    };
    saveTodayTasks();
  }, [blocks]);

  const saveHistory = () => {
    setHistory([...history, blocks]);
    setFuture([]);
  };

  const handleUndo = () => {
    if (history.length > 0) {
      setFuture([blocks, ...future]);
      const previousState = history[history.length - 1];
      setHistory(history.slice(0, -1));
      setBlocks(previousState);
    }
  };

  const handleRestore = () => {
    if (future.length > 0) {
      setHistory([...history, blocks]);
      const nextState = future[0];
      setFuture(future.slice(1));
      setBlocks(nextState);
    }
  };

  const updateTimeBlocks = (newInterval, newDayStart, newDayEnd) => {
    setBlocks(generateTimeBlocks(newInterval, newDayStart, newDayEnd));
    setDayStart(newDayStart);
    setDayEnd(newDayEnd);
  };

  const toggleSelectMode = () => {
    setIsSelecting(!isSelecting);
    setSelectedBlocks([]);
  };

  const handleBlockPressEntryMode = (block) => {
    setEntryBlock(block);
    setModalVisible(true);
  };

  const handleBlockPressSelectMode = (block) => {
    if (selectedBlocks.length === 0) {
      setSelectedBlocks([block]);
    } else {
      const lastSelected = selectedBlocks[selectedBlocks.length - 1];
      const blockIndex = parseInt(block.id);
      const lastIndex = parseInt(lastSelected.id);

      if (blockIndex > lastIndex) {
        const newSelection = blocks.slice(lastIndex, blockIndex + 1);
        setSelectedBlocks(newSelection);
      } else {
        const newSelection = blocks.slice(blockIndex, lastIndex + 1);
        setSelectedBlocks(newSelection);
      }
    }
  };

  const handleSplit = () => {
    if (selectedBlocks.length === 1) {
      saveHistory();

      const block = selectedBlocks[0];
      const [startTime, endTime] = block.time.split('-');
      let [startHour, startMinute] = startTime.split(':').map(Number);
      let [endHour, endMinute] = endTime.split(':').map(Number);

      const startTotalMinutes = startHour * 60 + startMinute;
      const endTotalMinutes = endHour * 60 + endMinute;
      const totalMinutes = endTotalMinutes - startTotalMinutes;

      const numBlocks = totalMinutes / 5;

      const newBlocks = [];

      for (let i = 0; i < numBlocks; i++) {
        const newStartTime = `${startHour.toString().padStart(2, '0')}:${startMinute
          .toString()
          .padStart(2, '0')}`;
        startMinute += 5;
        if (startMinute === 60) {
          startMinute = 0;
          startHour += 1;
        }
        const newEndTime = `${startHour.toString().padStart(2, '0')}:${startMinute
          .toString()
          .padStart(2, '0')}`;

        newBlocks.push({
          id: `${block.id}-${i}`,
          time: `${newStartTime}-${newEndTime}`,
          title: '',
          description: '',
          priority: 'none',
        });
      }

      const updatedBlocks = [
        ...blocks.slice(0, parseInt(block.id)),
        ...newBlocks,
        ...blocks.slice(parseInt(block.id) + 1),
      ];

      const reassignedBlocks = updatedBlocks.map((block, index) => ({
        ...block,
        id: index.toString(),
      }));

      setBlocks(reassignedBlocks);
      setSelectedBlocks([]);
      setIsSelecting(false);
    }
  };

  const handleAddTodo = (newTask) => {
    saveHistory();

    const updatedBlocks = blocks.map((block) =>
      entryBlock && block.id === entryBlock.id
        ? { ...block, ...newTask }
        : block
    );
    setBlocks(updatedBlocks);
    setSelectedBlocks([]);
    setEntryBlock(null);
    setModalVisible(false);
  };

  const handleMerge = () => {
    if (selectedBlocks.length > 1) {
      saveHistory();
      const firstBlock = selectedBlocks[0];
      const lastBlock = selectedBlocks[selectedBlocks.length - 1];
      const updatedTimeRange = `${firstBlock.time.split('-')[0]}-${lastBlock.time.split('-')[1]}`;
      const updatedFirstBlock = { ...firstBlock, time: updatedTimeRange };
  
      const updatedBlocks = blocks
        .filter(block => !selectedBlocks.find(selected => selected.id === block.id) || block.id === firstBlock.id)
        .map(block => (block.id === firstBlock.id ? updatedFirstBlock : block));
  
      const reassignedBlocks = updatedBlocks.map((block, index) => ({ ...block, id: index.toString() }));
      setBlocks(reassignedBlocks);
      setSelectedBlocks([]);
      setIsSelecting(false);
  
      locateCurrentBlock();  // Recalculate current block after merge
    }
  };

  const handleCancel = () => {
    setSelectedBlocks([]);
  };

  const getPriorityColor = (priority) => {
    switch (priority) {
      case 'p1':
        return customPriorities.p1.color;
      case 'p2':
        return customPriorities.p2.color;
      case 'p3':
        return customPriorities.p3.color;
      case 'p4':
        return customPriorities.p4.color;
      default:
        return 'transparent';
    }
  };

  const renderBlock = ({ item }) => (
    <View style={styles.blockContainer}>
      <TouchableOpacity
        style={[
          styles.block,
          { backgroundColor: getPriorityColor(item.priority) },
          selectedBlocks.find(block => block.id === item.id) ? styles.selectedBlock : null
        ]}
        onPress={() =>
          isSelecting ? handleBlockPressSelectMode(item) : handleBlockPressEntryMode(item)
        }
      >
        <Text style={styles.timeText}>{item.time}</Text>
        {item.title ? (
          <View>
            <Text style={styles.title}>{item.title}</Text>
            {item.description ? (
              <Text style={styles.description}>{item.description}</Text>
            ) : null}
          </View>
        ) : (
          <Text style={styles.emptyText}>Empty</Text>
        )}
      </TouchableOpacity>
      
      {/* Red line for current block */}
      {currentBlockId === item.id && currentTimeFraction !== null && (
        <View style={[styles.redLine, { top: `${currentTimeFraction * 100}%` }]} />
      )}
    </View>
  );

  return (
    <View style={styles.container}>
      <View style={styles.headerContainer}>
        <TouchableOpacity onPress={() => setSettingsVisible(true)}>
          <Icon name="settings" size={30} color="#1E8AFF" />
        </TouchableOpacity>
        <Button title="↺" onPress={handleUndo} disabled={history.length === 0} />
        <Button title="↻" onPress={handleRestore} disabled={future.length === 0} />
        <Button title={isSelecting ? "Cancel Select" : "Select"} onPress={toggleSelectMode} />
      </View>
      <Text style={styles.header}>{getFormattedDate()}</Text>


      <SettingsModal
        visible={settingsVisible}
        onClose={() => setSettingsVisible(false)}
        timeInterval={timeInterval}
        setTimeInterval={setTimeInterval}
        customPriorities={customPriorities}
        setCustomPriorities={setCustomPriorities}
        updateTimeBlocks={updateTimeBlocks}
        selectedDayStart={dayStart}
        selectedDayEnd={dayEnd}
        setSelectedDayStart={setDayStart}
        setSelectedDayEnd={setDayEnd}
      />

      <FlatList
        data={blocks}
        keyExtractor={(item) => item.id}
        renderItem={renderBlock}
      />

      {isSelecting && selectedBlocks.length > 1 && (
        <View style={styles.selectionOptions}>
          <Button title="Merge" onPress={handleMerge} />
          <Button title="Cancel" onPress={handleCancel} />
        </View>
      )}

      {isSelecting && selectedBlocks.length === 1 && (
        <View style={styles.selectionOptions}>
          <Button title="Split" onPress={handleSplit} />
          <Button title="Cancel" onPress={handleCancel} />
        </View>
      )}

      <AddTodoModal
        visible={modalVisible}
        onClose={() => {
          setModalVisible(false);
          setSelectedBlocks([]);
          setEntryBlock(null);
        }}
        onAddTodo={handleAddTodo}
        initialTitle={entryBlock?.title}
        initialDescription={entryBlock?.description}
        initialPriority={entryBlock?.priority}
        customPriorities={customPriorities}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 10,
    backgroundColor: '#fff',
  },
  headerContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 10,
    marginLeft: 15,
    marginRight: 15,
  },
  header: {
    fontSize: 24,
    fontWeight: 'bold',
  },
  blockContainer: {
    position: 'relative',  // Allow absolute positioning of the red line
  },
  block: {
    padding: 15,
    borderBottomWidth: 1,
    borderColor: '#eee',
    minHeight: 60,
    borderRadius: 10,
  },
  selectedBlock: {
    borderColor: '#00f',
    borderWidth: 2,
    borderRadius: 10,
  },
  timeText: {
    fontSize: 16,
    color: '#666',
    flexWrap: 'wrap',
  },
  title: {
    fontSize: 16,
    fontWeight: 'bold',
    marginTop: 5,
    flexWrap: 'wrap',
  },
  description: {
    fontSize: 14,
    color: 'blue',
    marginTop: 3,
    flexWrap: 'wrap',
  },
  emptyText: {
    fontSize: 14,
    color: '#aaa',
  },
  selectionOptions: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    marginTop: 10,
  },
  redLine: {
    position: 'absolute',  // The red line is positioned absolutely inside the block
    height: 2,             // Set a thin height for the red line
    backgroundColor: 'red',
    width: '100%',         // Stretch the red line to the full width of the block
  },
});

export default TodayScreen;

// TomorrowScreen.js

import React, { useState, useEffect } from 'react';
import { View, Text, StyleSheet, FlatList, TouchableOpacity, Button } from 'react-native';
import { usePriorities } from '../components/PrioritiesContext';

import AsyncStorage from '@react-native-async-storage/async-storage';
import Icon from 'react-native-vector-icons/MaterialIcons';
import AddTodoModal from '../components/AddTodoModal';
import SettingsModal from '../components/SettingsModal';

// Function to get tomorrow's date in the format "Wed, Oct 23"
const getFormattedDate = () => {
    const today = new Date();
    const tomorrow = new Date(today);
    tomorrow.setDate(today.getDate() + 1);
    return new Intl.DateTimeFormat('en-US', {
      weekday: 'long',
      month: 'short',
      day: 'numeric',
    }).format(tomorrow); // Outputs in the format: Wed, Oct 23
  };

const generateTimeBlocks = (interval = 15, dayStart = '6:00', dayEnd = '23:00') => {
  const blocks = [];
  let [startHour, startMinute] = dayStart.split(':').map(Number);
  let [endHour, endMinute] = dayEnd.split(':').map(Number);

  if (endHour === 0) endHour = 24;

  const startTotalMinutes = startHour * 60 + startMinute;
  const endTotalMinutes = endHour * 60 + endMinute;
  const totalMinutes = endTotalMinutes - startTotalMinutes;
  const totalBlocks = Math.floor(totalMinutes / interval);
  let currentMinutes = startTotalMinutes;

  for (let i = 0; i < totalBlocks; i++) {
    const startHour = Math.floor(currentMinutes / 60);
    const startMinute = currentMinutes % 60;
    const startTime = `${startHour.toString().padStart(2, '0')}:${startMinute
      .toString()
      .padStart(2, '0')}`;

    currentMinutes += interval;

    let endHour = Math.floor(currentMinutes / 60);
    if (endHour === 24) endHour = 0;
    const endMinute = currentMinutes % 60;
    const endTime = `${endHour.toString().padStart(2, '0')}:${endMinute
      .toString()
      .padStart(2, '0')}`;

    const timeRange = `${startTime}-${endTime}`;

    blocks.push({ id: i.toString(), time: timeRange, title: '', description: '', priority: 'none' });
  }

  return blocks;
};

const TomorrowScreen = () => {
  const { customPriorities, setCustomPriorities } = usePriorities();
  const [dayStart, setDayStart] = useState('6:00');
  const [dayEnd, setDayEnd] = useState('23:00');
  const [blocks, setBlocks] = useState(generateTimeBlocks());
  const [selectedBlocks, setSelectedBlocks] = useState([]);
  const [modalVisible, setModalVisible] = useState(false);
  const [settingsVisible, setSettingsVisible] = useState(false);
  const [isSelecting, setIsSelecting] = useState(false);
  const [entryBlock, setEntryBlock] = useState(null);
  const [history, setHistory] = useState([]);
  const [future, setFuture] = useState([]);

  const [timeInterval, setTimeInterval] = useState(15);
  // const [customPriorities, setCustomPriorities] = useState({
  //   p1: { label: 'p1', color: '#D6B4FC' },
  //   p2: { label: 'p2', color: '#FF8184' },
  //   p3: { label: 'p3', color: '#FDAA48' },
  //   p4: { label: 'p4', color: '#FFFFC5' }
  // });

  useEffect(() => {
    const loadTomorrowTasks = async () => {
      const storedBlocks = await AsyncStorage.getItem('tomorrowTasks');
      if (storedBlocks) {
        setBlocks(JSON.parse(storedBlocks));
      }
    };
    loadTomorrowTasks();
  }, []);

  useEffect(() => {
    // Save blocks to AsyncStorage when updated
    const saveTomorrowTasks = async () => {
      await AsyncStorage.setItem('tomorrowTasks', JSON.stringify(blocks));
    };
    saveTomorrowTasks();
  }, [blocks]);

  const saveHistory = () => {
    setHistory([...history, blocks]);
    setFuture([]);
  };

  const handleUndo = () => {
    if (history.length > 0) {
      setFuture([blocks, ...future]);
      const previousState = history[history.length - 1];
      setHistory(history.slice(0, -1));
      setBlocks(previousState);
    }
  };

  const handleRestore = () => {
    if (future.length > 0) {
      setHistory([...history, blocks]);
      const nextState = future[0];
      setFuture(future.slice(1));
      setBlocks(nextState);
    }
  };

  const updateTimeBlocks = (newInterval, newDayStart, newDayEnd) => {
    setBlocks(generateTimeBlocks(newInterval, newDayStart, newDayEnd));
    setDayStart(newDayStart);
    setDayEnd(newDayEnd);
  };

  const toggleSelectMode = () => {
    setIsSelecting(!isSelecting);
    setSelectedBlocks([]);
  };

  const handleBlockPressEntryMode = (block) => {
    setEntryBlock(block);
    setModalVisible(true);
  };

  const handleBlockPressSelectMode = (block) => {
    if (selectedBlocks.length === 0) {
      setSelectedBlocks([block]);
    } else {
      const lastSelected = selectedBlocks[selectedBlocks.length - 1];
      const blockIndex = parseInt(block.id);
      const lastIndex = parseInt(lastSelected.id);

      if (blockIndex > lastIndex) {
        const newSelection = blocks.slice(lastIndex, blockIndex + 1);
        setSelectedBlocks(newSelection);
      } else {
        const newSelection = blocks.slice(blockIndex, lastIndex + 1);
        setSelectedBlocks(newSelection);
      }
    }
  };

  const handleSplit = () => {
    if (selectedBlocks.length === 1) {
      saveHistory();

      const block = selectedBlocks[0];
      const [startTime, endTime] = block.time.split('-');
      let [startHour, startMinute] = startTime.split(':').map(Number);
      let [endHour, endMinute] = endTime.split(':').map(Number);

      const startTotalMinutes = startHour * 60 + startMinute;
      const endTotalMinutes = endHour * 60 + endMinute;
      const totalMinutes = endTotalMinutes - startTotalMinutes;

      const numBlocks = totalMinutes / 5;

      const newBlocks = [];

      for (let i = 0; i < numBlocks; i++) {
        const newStartTime = `${startHour.toString().padStart(2, '0')}:${startMinute
          .toString()
          .padStart(2, '0')}`;
        startMinute += 5;
        if (startMinute === 60) {
          startMinute = 0;
          startHour += 1;
        }
        const newEndTime = `${startHour.toString().padStart(2, '0')}:${startMinute
          .toString()
          .padStart(2, '0')}`;

        newBlocks.push({
          id: `${block.id}-${i}`,
          time: `${newStartTime}-${newEndTime}`,
          title: '',
          description: '',
          priority: 'none',
        });
      }

      const updatedBlocks = [
        ...blocks.slice(0, parseInt(block.id)),
        ...newBlocks,
        ...blocks.slice(parseInt(block.id) + 1),
      ];

      const reassignedBlocks = updatedBlocks.map((block, index) => ({
        ...block,
        id: index.toString(),
      }));

      setBlocks(reassignedBlocks);
      setSelectedBlocks([]);
      setIsSelecting(false);
    }
  };

  const handleAddTodo = (newTask) => {
    saveHistory();

    const updatedBlocks = blocks.map((block) =>
      entryBlock && block.id === entryBlock.id
        ? { ...block, ...newTask }
        : block
    );
    setBlocks(updatedBlocks);
    setSelectedBlocks([]);
    setEntryBlock(null);
    setModalVisible(false);
  };

  const handleMerge = () => {
    if (selectedBlocks.length > 1) {
      saveHistory();
  
      const firstBlock = selectedBlocks[0];
      const lastBlock = selectedBlocks[selectedBlocks.length - 1];
  
      // Create a new time range for the first block, covering the full selected range
      const updatedTimeRange = `${firstBlock.time.split('-')[0]}-${lastBlock.time.split('-')[1]}`;
  
      // Update the first block with the new time range and other info
      const updatedFirstBlock = { ...firstBlock, time: updatedTimeRange };
  
      // Update the block list, keeping only the first block and removing the others
      const updatedBlocks = blocks
        .filter(block => !selectedBlocks.find(selected => selected.id === block.id) || block.id === firstBlock.id)
        .map(block => (block.id === firstBlock.id ? updatedFirstBlock : block));
  
      // Reassign unique IDs to all blocks based on their index in the updated array
      const reassignedBlocks = updatedBlocks.map((block, index) => ({ ...block, id: index.toString() }));
  
      setBlocks(reassignedBlocks);
      setSelectedBlocks([]); // Clear the selection after merge
      setIsSelecting(false); // Automatically return to entry mode
    }
  };

  const handleCancel = () => {
    setSelectedBlocks([]);
  };

  const getPriorityColor = (priority) => {
    switch (priority) {
      case 'p1':
        return customPriorities.p1.color;
      case 'p2':
        return customPriorities.p2.color;
      case 'p3':
        return customPriorities.p3.color;
      case 'p4':
        return customPriorities.p4.color;
      default:
        return 'transparent';
    }
  };

  const renderBlock = ({ item }) => (
    <TouchableOpacity
      style={[
        styles.block,
        { backgroundColor: getPriorityColor(item.priority) },
        selectedBlocks.find(block => block.id === item.id) ? styles.selectedBlock : null
      ]}
      onPress={() =>
        isSelecting ? handleBlockPressSelectMode(item) : handleBlockPressEntryMode(item)
      }
    >
      <Text style={styles.timeText}>{item.time}</Text>
      {item.title ? (
        <View>
          <Text style={styles.title}>{item.title}</Text>
          {item.description ? (
            <Text style={styles.description}>{item.description}</Text>
          ) : null}
        </View>
      ) : (
        <Text style={styles.emptyText}>Empty</Text>
      )}
    </TouchableOpacity>
  );

  return (
    <View style={styles.container}>
      <View style={styles.headerContainer}>
        
        <TouchableOpacity onPress={() => setSettingsVisible(true)}>
          <Icon name="settings" size={30} color="#1E8AFF" />
        </TouchableOpacity>
        <Button title="↺" onPress={handleUndo} disabled={history.length === 0} />
        <Button title="↻" onPress={handleRestore} disabled={future.length === 0} />
        <Button title={isSelecting ? "Cancel Select" : "Select"} onPress={toggleSelectMode} />
      </View>
      <Text style={styles.header}>{getFormattedDate()}</Text>

      <SettingsModal
        visible={settingsVisible}
        onClose={() => setSettingsVisible(false)}
        timeInterval={timeInterval}
        setTimeInterval={setTimeInterval}
        customPriorities={customPriorities}
        setCustomPriorities={setCustomPriorities}
        updateTimeBlocks={updateTimeBlocks}
        selectedDayStart={dayStart}
        selectedDayEnd={dayEnd}
        setSelectedDayStart={setDayStart}
        setSelectedDayEnd={setDayEnd}
      />

      <FlatList
        data={blocks}
        keyExtractor={(item) => item.id}
        renderItem={renderBlock}
      />

      {isSelecting && selectedBlocks.length > 1 && (
        <View style={styles.selectionOptions}>
          <Button title="Merge" onPress={handleMerge} />
          <Button title="Cancel" onPress={handleCancel} />
        </View>
      )}

      {isSelecting && selectedBlocks.length === 1 && (
        <View style={styles.selectionOptions}>
          <Button title="Split" onPress={handleSplit} />
          <Button title="Cancel" onPress={handleCancel} />
        </View>
      )}

      <AddTodoModal
        visible={modalVisible}
        onClose={() => {
          setModalVisible(false);
          setSelectedBlocks([]);
          setEntryBlock(null);
        }}
        onAddTodo={handleAddTodo}
        initialTitle={entryBlock?.title}
        initialDescription={entryBlock?.description}
        initialPriority={entryBlock?.priority}
        customPriorities={customPriorities}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 10,
    backgroundColor: '#fff',
  },
  headerContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 10,
    marginLeft: 15,
    marginRight: 15,
  },
  header: {
    fontSize: 24,
    fontWeight: 'bold',
  },
  block: {
    padding: 15,
    borderBottomWidth: 1,
    borderColor: '#eee',
    minHeight: 60,
    borderRadius: 10, // Add this line to round the block's edges
  },
  selectedBlock: {
    borderColor: '#00f',
    borderWidth: 2,
    borderRadius: 10, // Add this line to round the edges of the selected block
  },
  timeText: {
    fontSize: 16,
    color: '#666',
    flexWrap: 'wrap',
  },
  title: {
    fontSize: 16,
    fontWeight: 'bold',
    marginTop: 5,
    flexWrap: 'wrap',
  },
  description: {
    fontSize: 14,
    color: 'blue',
    marginTop: 3,
    flexWrap: 'wrap',
  },
  emptyText: {
    fontSize: 14,
    color: '#aaa',
  },
  selectionOptions: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    marginTop: 10,
  },
});

export default TomorrowScreen;

// RoutineScreen.js

import React, { useState, useEffect } from 'react';
import { View, Text, StyleSheet, FlatList, TouchableOpacity, Button} from 'react-native';
import { Picker } from '@react-native-picker/picker';
import { usePriorities } from '../components/PrioritiesContext';

import AsyncStorage from '@react-native-async-storage/async-storage';
import Icon from 'react-native-vector-icons/MaterialIcons';
import AddTodoModal from '../components/AddTodoModal';
import SettingsModal from '../components/SettingsModal';

const generateTimeBlocks = (interval = 15, dayStart = '6:00', dayEnd = '23:00') => {
  const blocks = [];
  let [startHour, startMinute] = dayStart.split(':').map(Number);
  let [endHour, endMinute] = dayEnd.split(':').map(Number);

  if (endHour === 0) endHour = 24;

  const startTotalMinutes = startHour * 60 + startMinute;
  const endTotalMinutes = endHour * 60 + endMinute;
  const totalMinutes = endTotalMinutes - startTotalMinutes;
  const totalBlocks = Math.floor(totalMinutes / interval);
  let currentMinutes = startTotalMinutes;

  for (let i = 0; i < totalBlocks; i++) {
    const startHour = Math.floor(currentMinutes / 60);
    const startMinute = currentMinutes % 60;
    const startTime = `${startHour.toString().padStart(2, '0')}:${startMinute.toString().padStart(2, '0')}`;

    currentMinutes += interval;

    let endHour = Math.floor(currentMinutes / 60);
    if (endHour === 24) endHour = 0;
    const endMinute = currentMinutes % 60;
    const endTime = `${endHour.toString().padStart(2, '0')}:${endMinute.toString().padStart(2, '0')}`;

    const timeRange = `${startTime}-${endTime}`;

    blocks.push({ id: i.toString(), time: timeRange, title: '', description: '', priority: 'none' });
  }

  return blocks;
};

const RoutineScreen = () => {
  const { customPriorities, setCustomPriorities } = usePriorities();
  const [selectedDay, setSelectedDay] = useState('Monday');
  const [dayStart, setDayStart] = useState('6:00');
  const [dayEnd, setDayEnd] = useState('23:00');
  const [blocks, setBlocks] = useState(generateTimeBlocks());
  const [selectedBlocks, setSelectedBlocks] = useState([]);
  const [modalVisible, setModalVisible] = useState(false);
  const [settingsVisible, setSettingsVisible] = useState(false);
  const [isSelecting, setIsSelecting] = useState(false);
  const [entryBlock, setEntryBlock] = useState(null);
  const [history, setHistory] = useState([]);
  const [future, setFuture] = useState([]);

  const dayOptions = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];


  const [timeInterval, setTimeInterval] = useState(15);
//   const [customPriorities, setCustomPriorities] = useState({
//     p1: { label: 'p1', color: '#D6B4FC' },
//     p2: { label: 'p2', color: '#FF8184' },
//     p3: { label: 'p3', color: '#FDAA48' },
//     p4: { label: 'p4', color: '#FFFFC5' }
//   });

  useEffect(() => {
    const loadRoutine = async () => {
      const storedBlocks = await AsyncStorage.getItem(`routine${selectedDay}`);
      if (storedBlocks) {
        setBlocks(JSON.parse(storedBlocks));
      } else {
        setBlocks(generateTimeBlocks());
      }
    };
    loadRoutine();
  }, [selectedDay]);

  useEffect(() => {
    const saveRoutine = async () => {
      await AsyncStorage.setItem(`routine${selectedDay}`, JSON.stringify(blocks));
    };
    saveRoutine();
  }, [blocks, selectedDay]);

  const saveHistory = () => {
    setHistory([...history, blocks]);
    setFuture([]);
  };

  const handleUndo = () => {
    if (history.length > 0) {
      setFuture([blocks, ...future]);
      const previousState = history[history.length - 1];
      setHistory(history.slice(0, -1));
      setBlocks(previousState);
    }
  };

  const handleRestore = () => {
    if (future.length > 0) {
      setHistory([...history, blocks]);
      const nextState = future[0];
      setFuture(future.slice(1));
      setBlocks(nextState);
    }
  };

  const updateTimeBlocks = (newInterval, newDayStart, newDayEnd) => {
    setBlocks(generateTimeBlocks(newInterval, newDayStart, newDayEnd));
    setDayStart(newDayStart);
    setDayEnd(newDayEnd);
  };

  const toggleSelectMode = () => {
    setIsSelecting(!isSelecting);
    setSelectedBlocks([]);
  };

  const handleBlockPressEntryMode = (block) => {
    setEntryBlock(block);
    setModalVisible(true);
  };

  const handleBlockPressSelectMode = (block) => {
    if (selectedBlocks.length === 0) {
      setSelectedBlocks([block]);
    } else {
      const lastSelected = selectedBlocks[selectedBlocks.length - 1];
      const blockIndex = parseInt(block.id);
      const lastIndex = parseInt(lastSelected.id);

      if (blockIndex > lastIndex) {
        const newSelection = blocks.slice(lastIndex, blockIndex + 1);
        setSelectedBlocks(newSelection);
      } else {
        const newSelection = blocks.slice(blockIndex, lastIndex + 1);
        setSelectedBlocks(newSelection);
      }
    }
  };

  const handleSplit = () => {
    if (selectedBlocks.length === 1) {
      saveHistory();

      const block = selectedBlocks[0];
      const [startTime, endTime] = block.time.split('-');
      let [startHour, startMinute] = startTime.split(':').map(Number);
      let [endHour, endMinute] = endTime.split(':').map(Number);

      const startTotalMinutes = startHour * 60 + startMinute;
      const endTotalMinutes = endHour * 60 + endMinute;
      const totalMinutes = endTotalMinutes - startTotalMinutes;

      const numBlocks = totalMinutes / 5;

      const newBlocks = [];

      for (let i = 0; i < numBlocks; i++) {
        const newStartTime = `${startHour.toString().padStart(2, '0')}:${startMinute
          .toString()
          .padStart(2, '0')}`;
        startMinute += 5;
        if (startMinute === 60) {
          startMinute = 0;
          startHour += 1;
        }
        const newEndTime = `${startHour.toString().padStart(2, '0')}:${startMinute
          .toString()
          .padStart(2, '0')}`;

        newBlocks.push({
          id: `${block.id}-${i}`,
          time: `${newStartTime}-${newEndTime}`,
          title: '',
          description: '',
          priority: 'none',
        });
      }

      const updatedBlocks = [
        ...blocks.slice(0, parseInt(block.id)),
        ...newBlocks,
        ...blocks.slice(parseInt(block.id) + 1),
      ];

      const reassignedBlocks = updatedBlocks.map((block, index) => ({
        ...block,
        id: index.toString(),
      }));

      setBlocks(reassignedBlocks);
      setSelectedBlocks([]);
      setIsSelecting(false);
    }
  };

  const handleAddTodo = (newTask) => {
    saveHistory();

    const updatedBlocks = blocks.map((block) =>
      entryBlock && block.id === entryBlock.id
        ? { ...block, ...newTask }
        : block
    );
    setBlocks(updatedBlocks);
    setSelectedBlocks([]);
    setEntryBlock(null);
    setModalVisible(false);
  };

  const handleMerge = () => {
    if (selectedBlocks.length > 1) {
      saveHistory();
  
      const firstBlock = selectedBlocks[0];
      const lastBlock = selectedBlocks[selectedBlocks.length - 1];
  
      const updatedTimeRange = `${firstBlock.time.split('-')[0]}-${lastBlock.time.split('-')[1]}`;
  
      const updatedFirstBlock = { ...firstBlock, time: updatedTimeRange };
  
      const updatedBlocks = blocks
        .filter(block => !selectedBlocks.find(selected => selected.id === block.id) || block.id === firstBlock.id)
        .map(block => (block.id === firstBlock.id ? updatedFirstBlock : block));
  
      const reassignedBlocks = updatedBlocks.map((block, index) => ({ ...block, id: index.toString() }));
  
      setBlocks(reassignedBlocks);
      setSelectedBlocks([]);
      setIsSelecting(false);
    }
  };

  const handleCancel = () => {
    setSelectedBlocks([]);
  };

  const getPriorityColor = (priority) => {
    switch (priority) {
      case 'p1':
        return customPriorities.p1.color;
      case 'p2':
        return customPriorities.p2.color;
      case 'p3':
        return customPriorities.p3.color;
      case 'p4':
        return customPriorities.p4.color;
      default:
        return 'transparent';
    }
  };

  const renderBlock = ({ item }) => (
    <TouchableOpacity
      style={[
        styles.block,
        { backgroundColor: getPriorityColor(item.priority) },
        selectedBlocks.find(block => block.id === item.id) ? styles.selectedBlock : null
      ]}
      onPress={() =>
        isSelecting ? handleBlockPressSelectMode(item) : handleBlockPressEntryMode(item)
      }
    >
      <Text style={styles.timeText}>{item.time}</Text>
      {item.title ? (
        <View>
          <Text style={styles.title}>{item.title}</Text>
          {item.description ? (
            <Text style={styles.description}>{item.description}</Text>
          ) : null}
        </View>
      ) : (
        <Text style={styles.emptyText}>Empty</Text>
      )}
    </TouchableOpacity>
  );

  const renderDayOptions = () => {
    return (
      <View style={styles.timeZonePalette}>
        {dayOptions.map((day) => (
          <TouchableOpacity
            key={day}
            style={[
              styles.timeZoneOption,
              selectedDay === day ? styles.selectedDay : null,
            ]}
            onPress={() => setSelectedDay(day)}
          >
            <Text style={styles.intervalText}>{day}</Text>
          </TouchableOpacity>
        ))}
      </View>
    );
  };

  return (
    <View style={styles.container}>
      <View style={styles.headerContainer}>
        {/* <Text style={styles.header}>Routine for {selectedDay}</Text> */}
        <TouchableOpacity onPress={() => setSettingsVisible(true)}>
          <Icon name="settings" size={30} color="#1E8AFF" />
        </TouchableOpacity>
        <Button title="↺" onPress={handleUndo} disabled={history.length === 0} />
        <Button title="↻" onPress={handleRestore} disabled={future.length === 0} />
        <Button title={isSelecting ? "Cancel Select" : "Select"} onPress={toggleSelectMode} />
      </View>

      {renderDayOptions()}

      <SettingsModal
        visible={settingsVisible}
        onClose={() => setSettingsVisible(false)}
        timeInterval={timeInterval}
        setTimeInterval={setTimeInterval}
        customPriorities={customPriorities}
        setCustomPriorities={setCustomPriorities}
        updateTimeBlocks={updateTimeBlocks}
        selectedDayStart={dayStart}
        selectedDayEnd={dayEnd}
        setSelectedDayStart={setDayStart}
        setSelectedDayEnd={setDayEnd}
      />

<FlatList
        data={blocks}
        keyExtractor={(item) => item.id}
        renderItem={renderBlock}
      />

      {isSelecting && selectedBlocks.length > 1 && (
        <View style={styles.selectionOptions}>
          <Button title="Merge" onPress={handleMerge} />
          <Button title="Cancel" onPress={handleCancel} />
        </View>
      )}

      {isSelecting && selectedBlocks.length === 1 && (
        <View style={styles.selectionOptions}>
          <Button title="Split" onPress={handleSplit} />
          <Button title="Cancel" onPress={handleCancel} />
        </View>
      )}

<AddTodoModal
        visible={modalVisible}
        onClose={() => {
          setModalVisible(false);
          setSelectedBlocks([]);
          setEntryBlock(null);
        }}
        onAddTodo={handleAddTodo}
        initialTitle={entryBlock?.title}
        initialDescription={entryBlock?.description}
        initialPriority={entryBlock?.priority}
        customPriorities={customPriorities}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 10,
    backgroundColor: '#fff',
  },
  headerContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 10,
    marginLeft: 15,
    marginRight: 15,
  },
  header: {
    fontSize: 24,
    fontWeight: 'bold',
  },
  block: {
    padding: 15,
    borderBottomWidth: 1,
    borderColor: '#eee',
    minHeight: 60,
    borderRadius: 10,
  },
  selectedBlock: {
    borderColor: '#00f',
    borderWidth: 2,
    borderRadius: 10,
  },
  timeText: {
    fontSize: 16,
    color: '#666',
  },
  title: {
    fontSize: 16,
    fontWeight: 'bold',
    marginTop: 5,
    flexWrap: 'wrap',
  },
  description: {
    fontSize: 14,
    color: 'blue',
    marginTop: 3,
    flexWrap: 'wrap',
  },
  emptyText: {
    fontSize: 14,
    color: '#aaa',
  },
  timeZonePalette: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginBottom: 20,
  },
  timeZoneOption: {
    padding: 10,
    backgroundColor: '#e0e0e0',
    borderRadius: 8,
    margin: 5,
  },
  selectedDay: {
    backgroundColor: '#1E8AFF',
    fontWeight: 'bold',
  },
  intervalText: {
    fontSize: 16,
    color: 'black',
  },
  emptyText: {
    fontSize: 14,
    color: '#aaa',
  },
  selectionOptions: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    marginTop: 10,
  },
});

export default RoutineScreen;

// SettingsModal.js

import React, { useState } from 'react';
import { View, Text, Modal, Button, StyleSheet, TextInput, TouchableOpacity } from 'react-native';

// List of time zones with their respective UTC offsets
const timeZoneList = [
  { label: "Pacific Time (UTC-7)", value: "PST" },
  { label: "Mountain Time (UTC-6)", value: "MST" },
  { label: "Central Time (UTC-5)", value: "CST" },
  { label: "Eastern Time (UTC-4)", value: "EST" },
];

// const defaultPriorities = {
//   p1: { label: 'p1', color: '#D6B4FC' },
//   p2: { label: 'p2', color: '#FF8184' },
//   p3: { label: 'p3', color: '#FDAA48' },
//   p4: { label: 'p4', color: '#FFFFC5' }
// };

// Time options for Day Starts and Day Ends
const dayStartOptions = ['5:00', '6:00', '7:00', '8:00'];
const dayEndOptions = ['21:00', '22:00', '23:00', '0:00'];

const SettingsModal = ({
  visible,
  onClose,
  selectedDayStart, // Passed from parent
  selectedDayEnd,   // Passed from parent
  setSelectedDayStart, // Passed from parent
  setSelectedDayEnd,   // Passed from parent
  timeInterval,
  setTimeInterval,
  customPriorities,
  setCustomPriorities,
  updateTimeBlocks,
}) => {
    const [colorPaletteVisible, setColorPaletteVisible] = useState(null); // Track the visible color palette
    const [intervalVisible, setIntervalVisible] = useState(false); // Track schedule interval dropdown
    const [timeZoneVisible, setTimeZoneVisible] = useState(false); // Track time zone dropdown
    const [selectedTimeZone, setSelectedTimeZone] = useState('PST'); // Default to Pacific Time
    const [dayStartVisible, setDayStartVisible] = useState(false); // Track day starts dropdown visibility
    const [dayEndVisible, setDayEndVisible] = useState(false); // Track day ends dropdown visibility
    // const [selectedDayStart, setSelectedDayStart] = useState(selectedDayStart || '6:00');
    // const [selectedDayEnd, setSelectedDayEnd] = useState(selectedDayEnd || '23:00');
  
  
    const handleSaveSettings = () => {
        updateTimeBlocks(timeInterval, selectedDayStart, selectedDayEnd); // Pass day start and end times
        onClose();
    };

  // Function to add a new priority item
  const addNewPriority = () => {
    const newKey = `p${Object.keys(customPriorities).length + 1}`;
    setCustomPriorities((prev) => ({
      ...prev,
      [newKey]: { label: newKey, color: '#D3D3D3' }, // Default to grey
    }));
  };

  // Function to handle color selection
  const handleColorSelect = (priorityKey, color) => {
    setCustomPriorities((prev) => ({
      ...prev,
      [priorityKey]: { ...prev[priorityKey], color },
    }));
    setColorPaletteVisible(null); // Hide the color palette after selection
  };

  // Render the color palette
  const renderColorPalette = (priorityKey) => {
    const colors = ['#D6B4FC', '#FF8184', '#FDAA48', '#FFFFC5', '#D1FFBD', '#90D5FF', '#D3D3D3'];

    return (
      <View style={styles.colorPalette}>
        {colors.map((color) => (
          <TouchableOpacity
            key={color}
            style={[styles.colorOption, { backgroundColor: color }]}
            onPress={() => handleColorSelect(priorityKey, color)}
          />
        ))}
      </View>
    );
  };

  const renderPriorityButton = (priorityKey) => {
    const priority = customPriorities[priorityKey];
    return (
      <View key={priorityKey} style={styles.priorityBlock}>
        <View style={styles.priorityRow}>
          {/* Priority Color Button */}
          <TouchableOpacity
            style={[styles.priorityButton, { backgroundColor: priority.color }]}
            onPress={() =>
              setColorPaletteVisible((prev) => (prev === priorityKey ? null : priorityKey))
            }
          >
            <Text style={styles.priorityButtonText}>{priority.label}</Text>
          </TouchableOpacity>

          {/* Text input for label name */}
          <TextInput
            style={styles.priorityInput}
            value={customPriorities[priorityKey].label}
            onChangeText={(text) =>
              setCustomPriorities((prev) => ({
                ...prev,
                [priorityKey]: { ...prev[priorityKey], label: text },
              }))
            }
          />

          {/* Delete button */}
          <TouchableOpacity
            onPress={() => {
              const newPriorities = { ...customPriorities };
              delete newPriorities[priorityKey];
              setCustomPriorities(newPriorities);
            }}
          >
            <Text style={styles.deleteButton}>🗑️</Text>
          </TouchableOpacity>
        </View>

        {/* Render the color palette below the priority row if visible */}
        {colorPaletteVisible === priorityKey && renderColorPalette(priorityKey)}
      </View>
    );
  };

  // Day Starts Dropdown
  const renderDayStartOptions = () => {
    return (
      <View style={styles.timeZonePalette}>
        {dayStartOptions.map((start) => (
          <TouchableOpacity
            key={start}
            style={styles.timeZoneOption}
            onPress={() => {
              setSelectedDayStart(start);
              setDayStartVisible(false);
            }}
          >
            <Text style={styles.intervalText}>{start}</Text>
          </TouchableOpacity>
        ))}
      </View>
    );
  };

  // Day Ends Dropdown
  const renderDayEndOptions = () => {
    return (
      <View style={styles.timeZonePalette}>
        {dayEndOptions.map((end) => (
          <TouchableOpacity
            key={end}
            style={styles.timeZoneOption}
            onPress={() => {
              setSelectedDayEnd(end);
              setDayEndVisible(false);
            }}
          >
            <Text style={styles.intervalText}>{end}</Text>
          </TouchableOpacity>
        ))}
      </View>
    );
  };

  // Schedule Interval Selector (similar to color palette)
  const renderIntervalOptions = () => {
    const intervals = [10, 15, 20, 30];

    return (
      <View style={styles.intervalPalette}>
        {intervals.map((interval) => (
          <TouchableOpacity
            key={interval}
            style={styles.intervalOption}
            onPress={() => {
              setTimeInterval(interval);
              setIntervalVisible(false); // Hide interval options after selection
            }}
          >
            <Text style={styles.intervalText}>{`${interval} mins`}</Text>
          </TouchableOpacity>
        ))}
      </View>
    );
  };

  // Time Zone Selector (similar to schedule interval)
  const renderTimeZoneOptions = () => {
    return (
      <View style={styles.timeZonePalette}>
        {timeZoneList.map((zone) => (
          <TouchableOpacity
            key={zone.value}
            style={styles.timeZoneOption}
            onPress={() => {
              setSelectedTimeZone(zone.value);
              setTimeZoneVisible(false); // Hide time zone options after selection
            }}
          >
            <Text style={styles.intervalText}>{zone.label}</Text>
          </TouchableOpacity>
        ))}
      </View>
    );
  };

  return (
    <Modal visible={visible} animationType="slide" transparent={true}>
      <View style={styles.modalContainer}>
        <View style={styles.modalContent}>
          <Text style={styles.header}>Settings</Text>

          {/* Time Zone Selector */}
          <Text style={styles.subHeader}>Time Zone:</Text>
          <TouchableOpacity
            style={styles.intervalButton}
            onPress={() => setTimeZoneVisible((prev) => !prev)}
          >
            <Text style={styles.intervalButtonText}>
              {timeZoneList.find((tz) => tz.value === selectedTimeZone)?.label}
            </Text>
          </TouchableOpacity>
          {timeZoneVisible && renderTimeZoneOptions()}

          {/* Schedule Interval Selector */}
          <Text style={styles.subHeader}>Schedule Interval:</Text>
          <TouchableOpacity
            style={styles.intervalButton}
            onPress={() => setIntervalVisible((prev) => !prev)}
          >
            <Text style={styles.intervalButtonText}>{`${timeInterval} mins`}</Text>
          </TouchableOpacity>
          {intervalVisible && renderIntervalOptions()}

          {/* Day Starts and Day Ends Side by Side */}
          <View style={styles.dayTimeContainer}>
            <View style={styles.dayTimeBlock}>
              <Text style={styles.subHeader}>Day Starts:</Text>
              <TouchableOpacity
                style={styles.intervalButton}
                onPress={() => setDayStartVisible((prev) => !prev)}
              >
                <Text style={styles.intervalButtonText}>{selectedDayStart}</Text>
              </TouchableOpacity>
              {dayStartVisible && renderDayStartOptions()}
            </View>

            <View style={styles.dayTimeBlock}>
              <Text style={styles.subHeader}>Day Ends:</Text>
              <TouchableOpacity
                style={styles.intervalButton}
                onPress={() => setDayEndVisible((prev) => !prev)}
              >
                <Text style={styles.intervalButtonText}>{selectedDayEnd}</Text>
              </TouchableOpacity>
              {dayEndVisible && renderDayEndOptions()}
            </View>
          </View>

          <Text style={styles.subHeader}>Priority Labels:</Text>

          {/* Render priority buttons */}
          {Object.keys(customPriorities).map(renderPriorityButton)}

          {/* Button to add new priority */}
          <TouchableOpacity onPress={addNewPriority} style={styles.addButton}>
            <Text style={styles.addButtonText}>Add New Label</Text>
          </TouchableOpacity>

          {/* Save and Close Buttons */}
          <View style={styles.buttonRow}>
            <Button title="Save Settings" onPress={handleSaveSettings} />
            <Button title="Close" onPress={onClose} />
          </View>
        </View>
      </View>
    </Modal>
  );
};

const styles = StyleSheet.create({
    modalContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      backgroundColor: 'rgba(0, 0, 0, 0.5)',
    },
    modalContent: {
      width: '90%',
      backgroundColor: 'white',
      padding: 20,
      borderRadius: 10,
    },
    header: {
      fontSize: 20,
      fontWeight: 'bold',
      marginBottom: 20,
    },
    subHeader: {
      fontSize: 16,
      fontWeight: 'bold',
      marginTop: 10,
      marginBottom: 5,
    },
    intervalButton: {
      backgroundColor: '#f0f0f0',
      padding: 10,
      alignItems: 'center',
      borderRadius: 8,
      marginBottom: 10,
    },
    intervalButtonText: {
      fontSize: 16,
      color: 'black',
    },
    intervalPalette: {
      flexDirection: 'row',
      marginBottom: 20,
      justifyContent: 'space-between',
    },
    intervalOption: {
      padding: 10,
      backgroundColor: '#e0e0e0',
      borderRadius: 8,
    },
    timeZonePalette: {
      flexDirection: 'column',
      marginBottom: 20,
    },
    timeZoneOption: {
      padding: 10,
      backgroundColor: '#e0e0e0',
      borderRadius: 8,
      marginVertical: 2,
    },
    intervalText: {
      fontSize: 16,
      color: 'black',
    },
    dayTimeContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
    },
    dayTimeBlock: {
      flex: 1,
      marginHorizontal: 5, // Adds spacing between the two dropdowns
    },
    priorityBlock: {
      marginBottom: 20,
    },
    priorityRow: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    priorityButton: {
      width: 80,
      height: 40,
      borderRadius: 8,
      justifyContent: 'center',
      alignItems: 'center',
      marginRight: 10,
    },
    priorityButtonText: {
      color: 'black',
      fontWeight: 'bold',
    },
    priorityInput: {
      flex: 1,
      borderBottomWidth: 1,
      padding: 5,
      marginRight: 10,
    },
    deleteButton: {
      fontSize: 20,
      color: 'red',
    },
    addButton: {
      marginTop: 20,
      alignItems: 'center',
    },
    addButtonText: {
      color: '#1E8AFF',
      fontSize: 18,
    },
    buttonRow: {
      marginTop: 20,
    },
    colorPalette: {
      flexDirection: 'row',
      marginTop: 10,
      justifyContent: 'center',
    },
    colorOption: {
      width: 30,
      height: 30,
      borderRadius: 15,
      marginHorizontal: 5,
    },
  });

export default SettingsModal;

// AddTodoModal.js

import React, { useState, useEffect } from 'react';
import {
  Modal,
  View,
  Text,
  TextInput,
  Button,
  TouchableOpacity,
  StyleSheet,
} from 'react-native';

const AddTodoModal = ({ visible, onClose, onAddTodo, initialTitle, initialDescription, initialPriority, customPriorities = {}}) => {
    const [title, setTitle] = useState('');
    const [description, setDescription] = useState('');
    const [priority, setPriority] = useState('none');

  // Populate fields when modal opens with initial values
  useEffect(() => {
    if (visible) {
      setTitle(initialTitle || '');
      setDescription(initialDescription || '');
      setPriority(initialPriority || 'none');
    }
  }, [visible, initialTitle, initialDescription, initialPriority]);

  const handleAddTodo = () => {
    const newTask = {
      title,
      description,
      priority,
    };
    onAddTodo(newTask);
    setTitle('');
    setDescription('');
    setPriority('none'); // Reset to default
    onClose();
  };

  return (
    <Modal visible={visible} animationType="slide" transparent={true}>
      <View style={styles.modalContainer}>
        <View style={styles.modalContent}>
          <Text style={styles.header}>Add Task for This Time Block</Text>
          <TextInput
            placeholder="Title"
            style={styles.input}
            value={title}
            onChangeText={setTitle}
          />
          <TextInput
            placeholder="Description (Optional)"
            style={styles.input}
            value={description}
            onChangeText={setDescription}
          />

          {/* Priority Selection */}
          <View style={styles.priorityContainer}>
            <Text style={styles.priorityHeader}>Priority:</Text>

            {Object.keys(customPriorities).map((priorityKey) => {
              const priorityItem = customPriorities[priorityKey];
              return (
                <TouchableOpacity key={priorityKey} onPress={() => setPriority(priorityKey)}>
                  <Text
                    style={[
                      styles.priorityButton,
                      priority === priorityKey && styles.prioritySelected,
                      { backgroundColor: priorityItem.color },
                    ]}
                  >
                    {priorityItem.label}
                  </Text>
                </TouchableOpacity>
              );
            })}

            <TouchableOpacity onPress={() => setPriority('none')}>
              <Text
                style={[
                  styles.priorityButton,
                  priority === 'none' && styles.prioritySelected,
                  { backgroundColor: '#FFF' },
                ]}
              >
                None
              </Text>
            </TouchableOpacity>
          </View>

          {/* Add Task Button */}
          <Button title="Add Task" onPress={handleAddTodo} />

          {/* Close Modal */}
          <Button title="Close" onPress={onClose} />
        </View>
      </View>
    </Modal>
  );
};

const styles = StyleSheet.create({
    modalContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      backgroundColor: 'rgba(0, 0, 0, 0.5)',
    },
    modalContent: {
      width: '90%',
      backgroundColor: 'white',
      padding: 20,
      borderRadius: 10,
    },
    header: {
      fontSize: 20,
      fontWeight: 'bold',
      marginBottom: 20,
    },
    input: {
      borderBottomWidth: 1,
      marginBottom: 20,
      padding: 10,
    },
    priorityContainer: {
      flexDirection: 'row',
      justifyContent: 'space-around',
      marginBottom: 20,
      flexWrap: 'wrap',
    },
    priorityHeader: {
      fontSize: 16,
      fontWeight: 'bold',
      marginRight: 10,
    },
    priorityButton: {
      fontSize: 16,
      padding: 10,
      borderRadius: 5,
      borderWidth: 1,
      color: 'black',
      textAlign: 'center',
      margin: 5,
    },
    prioritySelected: {
      borderColor: '#333',
      borderWidth: 2,
    },
  });
  
  export default AddTodoModal;